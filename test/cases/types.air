`Empty type declaration
Island {}  `=> Air::Type

`Basic type declaration with members
`=> Air::Type
Transform {
	x = 0
	y = 0
}

`Type initialization with new keyword
`=> Air::Instance
Type {}
Type.new

`Type initialization with parens
`=> Air::Instance
Vector2 { x = 0, y = 1 }
Vector2()

`Type with value lookup
`=> 4
Vector1 { x = 4 }
Vector1.new.x

`Complex type with constructor
`=> 1
Vector2 { x = 1, y = 2 }
Transform {
	position = Vector2.new
}
t = Transform.new
t.position.x

`Union composition
`=> [1, 2, 10]
Aa {
	a = 1
}
Bb {
	a = 4; b = 2; unique = 10
}

Union | Aa | Bb {}

u = Union()
(u.a, u.b, u.unique)

`Difference composition
`=> [8, 23]
Aa {
	a = 8
	common = 15
}

Bb {
	b = 42
	common = 16
}

AaBb | Aa | Bb {}

Diff | AaBb ~ Bb {
	common = 23
}

d = Diff()
(d.a, d.common)

`Intersection composition
`=> 8
Aa { a = 4;  common = 8 }
Bb { b = 15; common = 16 }

Intersected | Aa & Bb {}

i = Intersected()
i.common

`Symmetric difference composition
`=> [4, 8]
Aa { a = 4; common = 10 }
Bb { b = 8; common = 10 }

Sym_Diff | Aa ^ Bb {}
s = Sym_Diff()
(s.a, s.b)

`Union is left-biased
`=> 4
Aa { a = 4 }
Bb { a = 8 }
Union | Aa | Bb {}
Union().a

`Nested type declaration
`=> Air::Type
Computer {
}

Island {
	Hatch {
		Commodore_64 | Computer {}
	}
}

Island.Hatch.Commodore_64

`Dot slash assignment and lookup
`=> 123
./x = 123
./x
